################################################################################
#                                                                              #
#                               GzIS Clang Format v0.2                         #
#                                                                              #
####################################################### author: HalisTahaŞahin #

# If true, horizontally aligns arguments after an open bracket.

# This applies to round brackets (parentheses), angle brackets and square brackets.

# Possible values:

# BAS_Align (in configuration: Align) Align parameters on the open bracket, e.g.:

# someLongFunction(argument1,
#                  argument2);
# BAS_DontAlign (in configuration: DontAlign) Don’t align, instead use ContinuationIndentWidth, e.g.:

# someLongFunction(argument1,
#     argument2);
# BAS_AlwaysBreak (in configuration: AlwaysBreak) Always break after an open bracket, if the parameters don’t fit on a single line, e.g.:

# someLongFunction(
#     argument1, argument2);
# BAS_BlockIndent (in configuration: BlockIndent) Always break after an open bracket, if the parameters don’t fit on a single line. Closing brackets will be placed on a new line. E.g.:

# someLongFunction(
#     argument1, argument2
# )
AlignAfterOpenBracket: Align

# if not None, when using initialization for an array of structs aligns the fields into columns.

# NOTE: As of clang-format 15 this option only applied to arrays with equal number of columns per row.

# Possible values:

# AIAS_Left (in configuration: Left) Align array column and left justify the columns e.g.:

# struct test demo[] =
# {
#     {56, 23,    "hello"},
#     {-1, 93463, "world"},
#     {7,  5,     "!!"   }
# };
# AIAS_Right (in configuration: Right) Align array column and right justify the columns e.g.:

# struct test demo[] =
# {
#     {56,    23, "hello"},
#     {-1, 93463, "world"},
#     { 7,     5,    "!!"}
# };
# AIAS_None (in configuration: None) Don’t align array initializer columns.
AlignArrayOfStructures: Right

# Style of aligning consecutive assignments.

# Consecutive will result in formattings like:

# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# Nested configuration flags:

# Alignment options.

# They can also be read as a whole for compatibility. The choices are: - None - Consecutive - AcrossEmptyLines - AcrossComments - AcrossEmptyLinesAndComments
AlignConsecutiveAssignments: AcrossEmptyLinesAndComments

# Style of aligning consecutive bit fields.

# Consecutive will align the bitfield separators of consecutive lines. This will result in formattings like:

# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
# Nested configuration flags:

# Alignment options.

# They can also be read as a whole for compatibility. The choices are: - None - Consecutive - AcrossEmptyLines - AcrossComments - AcrossEmptyLinesAndComments
AlignConsecutiveBitFields: AcrossEmptyLinesAndComments

# Style of aligning consecutive declarations.

# Consecutive will align the declaration names of consecutive lines. This will result in formattings like:

# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
# Nested configuration flags:

# Alignment options.

# They can also be read as a whole for compatibility. The choices are: - None - Consecutive - AcrossEmptyLines - AcrossComments - AcrossEmptyLinesAndComments
AlignConsecutiveDeclarations: AcrossEmptyLinesAndComments

# Style of aligning consecutive macro definitions.

# Consecutive will result in formattings like:

# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x * x)
# #define bar(y, z)        (y + z)
# Nested configuration flags:

# Alignment options.

# They can also be read as a whole for compatibility. The choices are: - None - Consecutive - AcrossEmptyLines - AcrossComments - AcrossEmptyLinesAndComments
AlignConsecutiveMacros: AcrossEmptyLinesAndComments

# Options for aligning backslashes in escaped newlines.

# Possible values:

# ENAS_DontAlign (in configuration: DontAlign) Don’t align escaped newlines.

# #define A \
#   int aaaa; \
#   int b; \
#   int dddddddddd;
# ENAS_Left (in configuration: Left) Align escaped newlines as far left as possible.

# true:
# #define A   \
#   int aaaa; \
#   int b;    \
#   int dddddddddd;

# false:
# ENAS_Right (in configuration: Right) Align escaped newlines in the right-most column.

# #define A                                                                      \
#   int aaaa;                                                                    \
#   int b;                                                                       \
#   int dddddddddd;
AlignEscapedNewlines: Right

# If true, horizontally align operands of binary and ternary expressions.

# Possible values:

# OAS_DontAlign (in configuration: DontAlign) Do not align operands of binary and ternary expressions. The wrapped lines are indented ContinuationIndentWidth spaces from the start of the line.

# OAS_Align (in configuration: Align) Horizontally align operands of binary and ternary expressions.

# Specifically, this aligns operands of a single expression that needs to be split over multiple lines, e.g.:

# int aaa = bbbbbbbbbbbbbbb +
#           ccccccccccccccc;
# When BreakBeforeBinaryOperators is set, the wrapped operator is aligned with the operand on the first line.

# int aaa = bbbbbbbbbbbbbbb
#           + ccccccccccccccc;
# OAS_AlignAfterOperator (in configuration: AlignAfterOperator) Horizontally align operands of binary and ternary expressions.

# This is similar to AO_Align, except when BreakBeforeBinaryOperators is set, the operator is un-indented so that the wrapped operand is aligned with the operand on the first line.

# int aaa = bbbbbbbbbbbbbbb
#         + ccccccccccccccc;
AlignOperands: Align

# If true, aligns trailing comments.

# true:                                   false:
# int a;     // My comment a      vs.     int a; // My comment a
# int b = 2; // comment  b                int b = 2; // comment about b
AlignTrailingComments: true

# If a function call or braced initializer list doesn’t fit on a line, allow putting all arguments onto the next line, even if BinPackArguments is false.

# true:
# callFunction(
#     a, b, c, d);

# false:
# callFunction(a,
#              b,
#              c,
#              d);
# AllowAllArgumentsOnNextLine: false

# If the function declaration doesn’t fit on a line, allow putting all parameters of a function declaration onto the next line even if BinPackParameters is false.

# true:
# void myFunction(
#     int a, int b, int c, int d, int e);

# false:
# void myFunction(int a,
#                 int b,
#                 int c,
#                 int d,
#                 int e);
# AllowAllParametersOfDeclarationOnNextLine: false

# Dependent on the value, while (true) { continue; } can be put on a single line.

# Possible values:

# SBS_Never (in configuration: Never) Never merge blocks into a single line.

# while (true) {
# }
# while (true) {
#   continue;
# }
# SBS_Empty (in configuration: Empty) Only merge empty blocks.

# while (true) {}
# while (true) {
#   continue;
# }
# SBS_Always (in configuration: Always) Always merge short blocks into a single line.

# while (true) {}
# while (true) { continue; }
AllowShortBlocksOnASingleLine: Never

# If true, short case labels will be contracted to a single line.

# true:                                   false:
# switch (a) {                    vs.     switch (a) {
# case 1: x = 1; break;                   case 1:
# case 2: return;                           x = 1;
# }                                         break;
#                                         case 2:
#                                           return;
#                                         }
AllowShortCaseLabelsOnASingleLine: false

# Allow short enums on a single line.

# true:
# enum { A, B } myEnum;

# false:
# enum {
#   A,
#   B
# } myEnum;
AllowShortEnumsOnASingleLine: false

# Dependent on the value, int f() { return 0; } can be put on a single line.

# Possible values:

# SFS_None (in configuration: None) Never merge functions into a single line.

# SFS_InlineOnly (in configuration: InlineOnly) Only merge functions defined inside a class. Same as “inline”, except it does not implies “empty”: i.e. top level empty functions are not merged either.

# class Foo {
#   void f() { foo(); }
# };
# void f() {
#   foo();
# }
# void f() {
# }
# SFS_Empty (in configuration: Empty) Only merge empty functions.

# void f() {}
# void f2() {
#   bar2();
# }
# SFS_Inline (in configuration: Inline) Only merge functions defined inside a class. Implies “empty”.

# class Foo {
#   void f() { foo(); }
# };
# void f() {
#   foo();
# }
# void f() {}
# SFS_All (in configuration: All) Merge all functions fitting on a single line.

# class Foo {
#   void f() { foo(); }
# };
# void f() { bar(); }
AllowShortFunctionsOnASingleLine: None

# Dependent on the value, if (a) return; can be put on a single line.

# Possible values:

# SIS_Never (in configuration: Never) Never put short ifs on the same line.

# if (a)
#   return;

# if (b)
#   return;
# else
#   return;

# if (c)
#   return;
# else {
#   return;
# }
# SIS_WithoutElse (in configuration: WithoutElse) Put short ifs on the same line only if there is no else statement.

# if (a) return;

# if (b)
#   return;
# else
#   return;

# if (c)
#   return;
# else {
#   return;
# }
# SIS_OnlyFirstIf (in configuration: OnlyFirstIf) Put short ifs, but not else ifs nor else statements, on the same line.

# if (a) return;

# if (b) return;
# else if (b)
#   return;
# else
#   return;

# if (c) return;
# else {
#   return;
# }
# SIS_AllIfsAndElse (in configuration: AllIfsAndElse) Always put short ifs, else ifs and else statements on the same line.

# if (a) return;

# if (b) return;
# else return;

# if (c) return;
# else {
#   return;
# }
AllowShortIfStatementsOnASingleLine: Never

# If true, while (true) continue; can be put on a single line.
AllowShortLoopsOnASingleLine: true

# The function declaration return type breaking style to use.

# Possible values:

# RTBS_None (in configuration: None) Break after return type automatically. PenaltyReturnTypeOnItsOwnLine is taken into account.

# class A {
#   int f() { return 0; };
# };
# int f();
# int f() { return 1; }
# RTBS_All (in configuration: All) Always break after the return type.

# class A {
#   int
#   f() {
#     return 0;
#   };
# };
# int
# f();
# int
# f() {
#   return 1;
# }
# RTBS_TopLevel (in configuration: TopLevel) Always break after the return types of top-level functions.

# class A {
#   int f() { return 0; };
# };
# int
# f();
# int
# f() {
#   return 1;
# }
# RTBS_AllDefinitions (in configuration: AllDefinitions) Always break after the return type of function definitions.

# class A {
#   int
#   f() {
#     return 0;
#   };
# };
# int f();
# int
# f() {
#   return 1;
# }
# RTBS_TopLevelDefinitions (in configuration: TopLevelDefinitions) Always break after the return type of top-level definitions.

# class A {
#   int f() { return 0; };
# };
# int f();
# int
# f() {
#   return 1;
# }
AlwaysBreakAfterReturnType: None

# true:                                  false:
# aaaa =                         vs.     aaaa = "bbbb"
#     "bbbb"                                    "cccc";
#     "cccc";
AlwaysBreakBeforeMultilineStrings: false

# A vector of strings that should be interpreted as attributes/qualifiers instead of identifiers. This can be useful for language extensions or static analyzer annotations.

# For example:

# x = (char *__capability)&y;
# int function(void) __ununsed;
# void only_writes_to_buffer(char *__output buffer);
# In the .clang-format configuration file, this can be configured like:
AttributeMacros: ['__capability', '__output', '__ununsed']

# If false, a function call’s arguments will either be all on the same line or will have one line each.

# true:
# void f() {
#   f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,
#     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
# }

# false:
# void f() {
#   f(aaaaaaaaaaaaaaaaaaaa,
#     aaaaaaaaaaaaaaaaaaaa,
#     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
# }
BinPackArguments: false 

# If false, a function declaration’s or function definition’s parameters will either all be on the same line or will have one line each.

# true:
# void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,
#        int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}

# false:
# void f(int aaaaaaaaaaaaaaaaaaaa,
#        int aaaaaaaaaaaaaaaaaaaa,
#        int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}
BinPackParameters: false 

# The BitFieldColonSpacingStyle to use for bitfields.

# Possible values:

# BFCS_Both (in configuration: Both) Add one space on each side of the :

# unsigned bf : 2;
# BFCS_None (in configuration: None) Add no space around the : (except when needed for AlignConsecutiveBitFields).

# unsigned bf:2;
# BFCS_Before (in configuration: Before) Add space before the : only

# unsigned bf :2;
# BFCS_After (in configuration: After) Add space after the : only (space may be added before if needed for AlignConsecutiveBitFields).

# unsigned bf: 2;
BitFieldColonSpacing: None

# Control of individual brace wrapping cases.

# If BreakBeforeBraces is set to BS_Custom, use this to specify how each individual brace case should be handled. Otherwise, this is ignored.

# # Example of usage:
# BreakBeforeBraces: Custom
# BraceWrapping:
#   AfterEnum: true
#   AfterStruct: false
#   SplitEmptyFunction: false
# Nested configuration flags:

# Precise control over the wrapping of braces.

# # Should be declared this way:
# BreakBeforeBraces: Custom
# BraceWrapping:
#     AfterClass: true
# bool AfterCaseLabel Wrap case labels.

# false:                                true:
# switch (foo) {                vs.     switch (foo) {
#   case 1: {                             case 1:
#     bar();                              {
#     break;                                bar();
#   }                                       break;
#   default: {                            }
#     plop();                             default:
#   }                                     {
# }                                         plop();
#                                         }
#                                       }
# bool AfterClass Wrap class definitions.

# true:
# class foo
# {};

# false:
# class foo {};
# BraceWrappingAfterControlStatementStyle AfterControlStatement Wrap control statements (if/for/while/switch/..).

# Possible values:

# BWACS_Never (in configuration: Never) Never wrap braces after a control statement.

# if (foo()) {
# } else {
# }
# for (int i = 0; i < 10; ++i) {
# }
# BWACS_MultiLine (in configuration: MultiLine) Only wrap braces after a multi-line control statement.

# if (foo && bar &&
#     baz)
# {
#   quux();
# }
# while (foo || bar) {
# }
# BWACS_Always (in configuration: Always) Always wrap braces after a control statement.

# if (foo())
# {
# } else
# {}
# for (int i = 0; i < 10; ++i)
# {}
# bool AfterEnum Wrap enum definitions.

# true:
# enum X : int
# {
#   B
# };

# false:
# enum X : int { B };
# bool AfterFunction Wrap function definitions.

# true:
# void foo()
# {
#   bar();
#   bar2();
# }

# false:
# void foo() {
#   bar();
#   bar2();
# }
# bool AfterNamespace Wrap namespace definitions.

# true:
# namespace
# {
# int foo();
# int bar();
# }

# false:
# namespace {
# int foo();
# int bar();
# }
# bool AfterObjCDeclaration Wrap ObjC definitions (interfaces, implementations…). @autoreleasepool and @synchronized blocks are wrapped according to AfterControlStatement flag.

# bool AfterStruct Wrap struct definitions.

# true:
# struct foo
# {
#   int x;
# };

# false:
# struct foo {
#   int x;
# };
# bool AfterUnion Wrap union definitions.

# true:
# union foo
# {
#   int x;
# }

# false:
# union foo {
#   int x;
# }
# bool AfterExternBlock Wrap extern blocks.

# true:
# extern "C"
# {
#   int foo();
# }

# false:
# extern "C" {
# int foo();
# }
# bool BeforeCatch Wrap before catch.

# true:
# try {
#   foo();
# }
# catch () {
# }

# false:
# try {
#   foo();
# } catch () {
# }
# bool BeforeElse Wrap before else.

# true:
# if (foo()) {
# }
# else {
# }

# false:
# if (foo()) {
# } else {
# }
# bool BeforeLambdaBody Wrap lambda block.

# true:
# connect(
#   []()
#   {
#     foo();
#     bar();
#   });

# false:
# connect([]() {
#   foo();
#   bar();
# });
# bool BeforeWhile Wrap before while.

# true:
# do {
#   foo();
# }
# while (1);

# false:
# do {
#   foo();
# } while (1);
# bool IndentBraces Indent the wrapped braces themselves.

# bool SplitEmptyFunction If false, empty function body can be put on a single line. This option is used only if the opening brace of the function has already been wrapped, i.e. the AfterFunction brace wrapping mode is set, and the function could/should not be put on a single line (as per AllowShortFunctionsOnASingleLine and constructor formatting options).

# false:          true:
# int f()   vs.   int f()
# {}              {
#                 }
# bool SplitEmptyRecord If false, empty record (e.g. class, struct or union) body can be put on a single line. This option is used only if the opening brace of the record has already been wrapped, i.e. the AfterClass (for classes) brace wrapping mode is set.

# false:           true:
# class Foo   vs.  class Foo
# {}               {
#                  }
# bool SplitEmptyNamespace If false, empty namespace body can be put on a single line. This option is used only if the opening brace of the namespace has already been wrapped, i.e. the AfterNamespace brace wrapping mode is set.

# false:               true:
# namespace Foo   vs.  namespace Foo
# {}                   {
#                      }
BreakBeforeBraces: Custom
BraceWrapping:
    AfterCaseLabel: true
    AfterControlStatement: Always
    AfterEnum: true
    AfterFunction: true
    AfterStruct: true
    AfterUnion: true
    AfterExternBlock: false
    BeforeElse: true
    BeforeWhile: false 
    IndentBraces: false
    SplitEmptyFunction: true

# The way to wrap binary operators.

# Possible values:

# BOS_None (in configuration: None) Break after operators.

# LooooooooooongType loooooooooooooooooooooongVariable =
#     someLooooooooooooooooongFunction();

# bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +
#                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==
#                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&
#              aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >
#                  ccccccccccccccccccccccccccccccccccccccccc;
# BOS_NonAssignment (in configuration: NonAssignment) Break before operators that aren’t assignments.

# LooooooooooongType loooooooooooooooooooooongVariable =
#     someLooooooooooooooooongFunction();

# bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                      + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                  == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#              && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                     > ccccccccccccccccccccccccccccccccccccccccc;
# BOS_All (in configuration: All) Break before operators.

# LooooooooooongType loooooooooooooooooooooongVariable
#     = someLooooooooooooooooongFunction();

# bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                      + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                  == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#              && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                     > ccccccccccccccccccccccccccccccccccccccccc;
BreakBeforeBinaryOperators: None

# If true, ternary operators will be placed after line breaks.

# true:
# veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription
#     ? firstValue
#     : SecondValueVeryVeryVeryVeryLong;

# false:
# veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?
#     firstValue :
#     SecondValueVeryVeryVeryVeryLong;
BreakBeforeTernaryOperators: true

# Allow breaking string literals when formatting.

# true:
# const char* x = "veryVeryVeryVeryVeryVe"
#                 "ryVeryVeryVeryVeryVery"
#                 "VeryLongString";

# false:
# const char* x =
#   "veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString";
BreakStringLiterals: true

# The column limit.

# A column limit of 0 means that there is no column limit. In this case, clang-format will respect the input’s line breaking decisions within statements unless they contradict other rules.
ColumnLimit: 80

# A regular expression that describes comments with special meaning, which should not be split into lines or otherwise changed.

# // CommentPragmas: '^ FOOBAR pragma:'
# // Will leave the following line unaffected
# #include <vector> // FOOBAR pragma: keep
CommentPragmas: '^ KEEP:'

# Indent width for line continuations.

# ContinuationIndentWidth: 2

# int i =         //  VeryVeryVeryVeryVeryLongComment
#   longFunction( // Again a long comment
#     arg);
ContinuationIndentWidth: 4

# Analyze the formatted file for the most used line ending (\r\n or \n). UseCRLF is only used as a fallback if none can be derived.
# DeriveLineEnding: false

# If true, analyze the formatted file for the most common alignment of & and *. Pointer and reference alignment styles are going to be updated according to the preferences found in the file. PointerAlignment is then used only as fallback.
# DerivePointerAlignment: true

# Disables formatting completely.
# DisableFormat: false 

# If true, clang-format detects whether function calls and definitions are formatted with one parameter per line.

# Each call can be bin-packed, one-per-line or inconclusive. If it is inconclusive, e.g. completely on one line, but a decision needs to be made, clang-format analyzes whether there are other bin-packed cases in the input file and act accordingly.

# NOTE: This is an experimental flag, that might go away or be renamed. Do not use this in config files, etc. Use at your own risk.
# ExperimentalAutoDetectBinPacking: true

# A vector of macros that should be interpreted as foreach loops instead of as function calls.

# These are expected to be macros of the form:

# FOREACH(<variable-declaration>, ...)
#   <loop-body>
# In the .clang-format configuration file, this can be configured like:
ForEachMacros: ['RANGES_FOR', 'FOREACH']

# A vector of macros that should be interpreted as conditionals instead of as function calls.

# These are expected to be macros of the form:

# IF(...)
#   <conditional-body>
# else IF(...)
#   <conditional-body>
# In the .clang-format configuration file, this can be configured like:
# IfMacros: ['IF']

# Dependent on the value, multiple #include blocks can be sorted as one and divided based on category.

# Possible values:

# IBS_Preserve (in configuration: Preserve) Sort each #include block separately.

# #include "b.h"               into      #include "b.h"

# #include <lib/main.h>                  #include "a.h"
# #include "a.h"                         #include <lib/main.h>
# IBS_Merge (in configuration: Merge) Merge multiple #include blocks together and sort as one.

# #include "b.h"               into      #include "a.h"
#                                        #include "b.h"
# #include <lib/main.h>                  #include <lib/main.h>
# #include "a.h"
# IBS_Regroup (in configuration: Regroup) Merge multiple #include blocks together and sort as one. Then split into groups based on category priority. See IncludeCategories.

# #include "b.h"               into      #include "a.h"
#                                        #include "b.h"
# #include <lib/main.h>
# #include "a.h"                         #include <lib/main.h>
IncludeBlocks: Regroup

# Regular expressions denoting the different #include categories used for ordering #includes.

# POSIX extended regular expressions are supported.

# These regular expressions are matched against the filename of an include (including the <> or “”) in order. The value belonging to the first matching regular expression is assigned and #includes are sorted first according to increasing category number and then alphabetically within each category.

# If none of the regular expressions match, INT_MAX is assigned as category. The main header for a source file automatically gets category 0. so that it is generally kept at the beginning of the #includes (https://llvm.org/docs/CodingStandards.html#include-style). However, you can also assign negative priorities if you have certain headers that always need to be first.

# There is a third and optional field SortPriority which can used while IncludeBlocks = IBS_Regroup to define the priority in which #includes should be ordered. The value of Priority defines the order of #include blocks and also allows the grouping of #includes of different priority. SortPriority is set to the value of Priority as default if it is not assigned.

# Each regular expression can be marked as case sensitive with the field CaseSensitive, per default it is not.

# To configure this in the .clang-format file, use:

# IncludeCategories:
#   - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
#     Priority:        2
#     SortPriority:    2
#     CaseSensitive:   true
#   - Regex:           '^((<|")(gtest|gmock|isl|json)/)'
#     Priority:        3
#   - Regex:           '<[[:alnum:].]+>'
#     Priority:        4
#   - Regex:           '.*'
#     Priority:        1
#     SortPriority:    0

# Indent case label blocks one level from the case label.

# When false, the block following the case label uses the same indentation level as for the case label, treating the case label the same as an if-statement. When true, the block gets indented as a scope block.

# false:                                 true:
# switch (fool) {                vs.     switch (fool) {
# case 1: {                              case 1:
#   bar();                                 {
# } break;                                   bar();
# default: {                               }
#   plop();                                break;
# }                                      default:
# }                                        {
#                                            plop();
#                                          }
#                                        }
IndentCaseBlocks: false 

# Indent case labels one level from the switch statement.

# When false, use the same indentation level as for the switch statement. Switch statement body is always indented one level more than case labels (except the first block following the case label, which itself indents the code - unless IndentCaseBlocks is enabled).

# false:                                 true:
# switch (fool) {                vs.     switch (fool) {
# case 1:                                  case 1:
#   bar();                                   bar();
#   break;                                   break;
# default:                                 default:
#   plop();                                  plop();
# }                                      }
IndentCaseLabels: true

# IndentExternBlockStyle is the type of indenting of extern blocks.

# Possible values:

# IEBS_AfterExternBlock (in configuration: AfterExternBlock) Backwards compatible with AfterExternBlock’s indenting.

# IndentExternBlock: AfterExternBlock
# BraceWrapping.AfterExternBlock: true
# extern "C"
# {
#     void foo();
# }
# IndentExternBlock: AfterExternBlock
# BraceWrapping.AfterExternBlock: false
# extern "C" {
# void foo();
# }
# IEBS_NoIndent (in configuration: NoIndent) Does not indent extern blocks.

# extern "C" {
# void foo();
# }
# IEBS_Indent (in configuration: Indent) Indents extern blocks.

# extern "C" {
#   void foo();
# }
IndentExternBlock: NoIndent

# Indent goto labels.

# When false, goto labels are flushed left.

# true:                                  false:
# int f() {                      vs.     int f() {
#   if (foo()) {                           if (foo()) {
#   label1:                              label1:
#     bar();                                 bar();
#   }                                      }
# label2:                                label2:
#   return 1;                              return 1;
# }                                      }
IndentGotoLabels: true

# The preprocessor directive indenting style to use.

# Possible values:

# PPDIS_None (in configuration: None) Does not indent any directives.

# #if FOO
# #if BAR
# #include <foo>
# #endif
# #endif
# PPDIS_AfterHash (in configuration: AfterHash) Indents directives after the hash.

# #if FOO
# #  if BAR
# #    include <foo>
# #  endif
# #endif
# PPDIS_BeforeHash (in configuration: BeforeHash) Indents directives before the hash.

# #if FOO
#   #if BAR
#     #include <foo>
#   #endif
# #endif
IndentPPDirectives: None

# The number of columns to use for indentation.

# IndentWidth: 3

# void f() {
#    someFunction();
#    if (true, false) {
#       f();
#    }
# }
IndentWidth: 4

# Indent if a function definition or declaration is wrapped after the type.

# true:
# LoooooooooooooooooooooooooooooooooooooooongReturnType
#     LoooooooooooooooooooooooooooooooongFunctionDeclaration();

# false:
# LoooooooooooooooooooooooooooooooooooooooongReturnType
# LoooooooooooooooooooooooooooooooongFunctionDeclaration();
IndentWrappedFunctionNames: true

# Insert braces after control statements (if, else, for, do, and while) in C++ unless the control statements are inside macro definitions or the braces would enclose preprocessor directives.

# Warning
# Setting this option to true could lead to incorrect code formatting due to clang-format’s lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.
# false:                                    true:

# if (isa<FunctionDecl>(D))        vs.      if (isa<FunctionDecl>(D)) {
#   handleFunctionDecl(D);                    handleFunctionDecl(D);
# else if (isa<VarDecl>(D))                 } else if (isa<VarDecl>(D)) {
#   handleVarDecl(D);                         handleVarDecl(D);
# else                                      } else {
#   return;                                   return;
#                                           }

# while (i--)                      vs.      while (i--) {
#   for (auto *A : D.attrs())                 for (auto *A : D.attrs()) {
#     handleAttr(A);                            handleAttr(A);
#                                             }
#                                           }

# do                               vs.      do {
#   --i;                                      --i;
# while (i);                                } while (i);
InsertBraces: true

# If true, the empty line at the start of blocks is kept.

# true:                                  false:
# if (foo) {                     vs.     if (foo) {
#                                          bar();
#   bar();                               }
# }
KeepEmptyLinesAtTheStartOfBlocks: false

# Language, this format style is targeted at.

# Possible values:

# LK_None (in configuration: None) Do not use.
# LK_Cpp (in configuration: Cpp) Should be used for C, C++.
Language: Cpp

# A regular expression matching macros that start a block.

# # With:
# MacroBlockBegin: "^NS_MAP_BEGIN|\
# NS_TABLE_HEAD$"
# MacroBlockEnd: "^\
# NS_MAP_END|\
# NS_TABLE_.*_END$"

# NS_MAP_BEGIN
#   foo();
# NS_MAP_END

# NS_TABLE_HEAD
#   bar();
# NS_TABLE_FOO_END

# # Without:
# NS_MAP_BEGIN
# foo();
# NS_MAP_END

# NS_TABLE_HEAD
# bar();
# NS_TABLE_FOO_END
# MacroBlockBegin: 

# A regular expression matching macros that end a block.
# MacroBlockEnd:

# The maximum number of consecutive empty lines to keep.

# MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0
# int f() {                              int f() {
#   int = 1;                                 int i = 1;
#                                            i = foo();
#   i = foo();                               return i;
#                                        }
#   return i;
# }
MaxEmptyLinesToKeep: 1

# The number of columns to use for indentation of preprocessor statements. When set to -1 (default) IndentWidth is used also for preprocessor statements.

# PPIndentWidth: 1

# #ifdef __linux__
# # define FOO
# #else
# # define BAR
# #endif
PPIndentWidth: 4

# # The penalty for breaking around an assignment operator.
# PenaltyBreakAssignment: 0

# # The penalty for breaking a function call after call(.
# PenaltyBreakBeforeFirstCallParameter: 0

# # The penalty for each line break introduced inside a comment.
# PenaltyBreakComment: 0

# # The penalty for breaking before the first <<.
# PenaltyBreakFirstLessLess: 0

# # The penalty for breaking after (.
# PenaltyBreakOpenParenthesis: 0

# # The penalty for each line break introduced inside a string literal.
# PenaltyBreakString: 0

# # The penalty for each character outside of the column limit.
# PenaltyExcessCharacter: 0

# # Penalty for each character of whitespace indentation (counted relative to leading non-whitespace column).
# PenaltyIndentedWhitespace: 0

# # Penalty for putting the return type of a function onto its own line.
# PenaltyReturnTypeOnItsOwnLine: 0

# Pointer and reference alignment style.

# Possible values:

# PAS_Left (in configuration: Left) Align pointer to the left.

# int* a;
# PAS_Right (in configuration: Right) Align pointer to the right.

# int *a;
# PAS_Middle (in configuration: Middle) Align pointer in the middle.

# int * a;
PointerAlignment: Left

# Different ways to arrange specifiers and qualifiers (e.g. const/volatile).

# Warning
# Setting QualifierAlignment to something other than Leave, COULD lead to incorrect code formatting due to incorrect decisions made due to clang-formats lack of complete semantic information. As such extra care should be taken to review code changes made by the use of this option.
# Possible values:

# QAS_Leave (in configuration: Leave) Don’t change specifiers/qualifiers to either Left or Right alignment (default).

# int const a;
# const int *a;
# QAS_Left (in configuration: Left) Change specifiers/qualifiers to be left-aligned.

# const int a;
# const int *a;
# QAS_Right (in configuration: Right) Change specifiers/qualifiers to be right-aligned.

# int const a;
# int const *a;
# QAS_Custom (in configuration: Custom) Change specifiers/qualifiers to be aligned based on QualifierOrder. With:

# QualifierOrder: ['inline', 'static', 'type', 'const']
# int const a;
# int const *a;
QualifierAlignment: Custom

# The order in which the qualifiers appear. Order is an array that can contain any of the following:

# const
# inline
# static
# constexpr
# volatile
# restrict
# type
# Note: it MUST contain ‘type’. Items to the left of ‘type’ will be placed to the left of the type and aligned in the order supplied. Items to the right of ‘type’ will be placed to the right of the type and aligned in the order supplied.
QualifierOrder: ['inline', 'static', 'const', 'type', 'volatile' ]

# Reference alignment style (overrides PointerAlignment for references).

# Possible values:

# RAS_Pointer (in configuration: Pointer) Align reference like PointerAlignment.

# RAS_Left (in configuration: Left) Align reference to the left.

# int& a;
# RAS_Right (in configuration: Right) Align reference to the right.

# int &a;
# RAS_Middle (in configuration: Middle) Align reference in the middle.

# int & a;
ReferenceAlignment: Right

# If true, clang-format will attempt to re-flow comments.

# false:
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */

# true:
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
# // information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
#  * information */
ReflowComments: true

# Specifies the use of empty lines to separate definition blocks, including classes, structs, enums, and functions.

# Never                  v.s.     Always
# #include <cstring>              #include <cstring>
# struct Foo {
#   int a, b, c;                  struct Foo {
# };                                int a, b, c;
# namespace Ns {                  };
# class Bar {
# public:                         namespace Ns {
#   struct Foobar {               class Bar {
#     int a;                      public:
#     int b;                        struct Foobar {
#   };                                int a;
# private:                            int b;
#   int t;                          };
#   int method1() {
#     // ...                      private:
#   }                               int t;
#   enum List {
#     ITEM1,                        int method1() {
#     ITEM2                           // ...
#   };                              }
#   template<typename T>
#   int method2(T x) {              enum List {
#     // ...                          ITEM1,
#   }                                 ITEM2
#   int i, j, k;                    };
#   int method3(int par) {
#     // ...                        template<typename T>
#   }                               int method2(T x) {
# };                                  // ...
# class C {};                       }
# }
#                                   int i, j, k;

#                                   int method3(int par) {
#                                     // ...
#                                   }
#                                 };

#                                 class C {};
#                                 }
# Possible values:

# SDS_Leave (in configuration: Leave) Leave definition blocks as they are.
# SDS_Always (in configuration: Always) Insert an empty line between definition blocks.
# SDS_Never (in configuration: Never) Remove any empty line between definition blocks.
SeparateDefinitionBlocks: Always

# Controls if and how clang-format will sort #includes. If Never, includes are never sorted. If CaseInsensitive, includes are sorted in an ASCIIbetical or case insensitive fashion. If CaseSensitive, includes are sorted in an alphabetical or case sensitive fashion.

# Possible values:

# SI_Never (in configuration: Never) Includes are never sorted.

# #include "B/A.h"
# #include "A/B.h"
# #include "a/b.h"
# #include "A/b.h"
# #include "B/a.h"
# SI_CaseSensitive (in configuration: CaseSensitive) Includes are sorted in an ASCIIbetical or case sensitive fashion.

# #include "A/B.h"
# #include "A/b.h"
# #include "B/A.h"
# #include "B/a.h"
# #include "a/b.h"
# SI_CaseInsensitive (in configuration: CaseInsensitive) Includes are sorted in an alphabetical or case insensitive fashion.

# #include "A/B.h"
# #include "A/b.h"
# #include "a/b.h"
# #include "B/A.h"
# #include "B/a.h"
# SortIncludes: CaseSensitive

# If true, a space is inserted after C style casts.

# true:                                  false:
# (int) i;                       vs.     (int)i;
SpaceAfterCStyleCast: true

# If true, a space is inserted after the logical not operator (!).

# true:                                  false:
# ! someExpression();            vs.     !someExpression();
SpaceAfterLogicalNot: true

# Defines in which cases to put a space before or after pointer qualifiers

# Possible values:

# SAPQ_Default (in configuration: Default) Don’t ensure spaces around pointer qualifiers and use PointerAlignment instead.

# PointerAlignment: Left                 PointerAlignment: Right
# void* const* x = NULL;         vs.     void *const *x = NULL;
# SAPQ_Before (in configuration: Before) Ensure that there is a space before pointer qualifiers.

# PointerAlignment: Left                 PointerAlignment: Right
# void* const* x = NULL;         vs.     void * const *x = NULL;
# SAPQ_After (in configuration: After) Ensure that there is a space after pointer qualifiers.

# PointerAlignment: Left                 PointerAlignment: Right
# void* const * x = NULL;         vs.     void *const *x = NULL;
# SAPQ_Both (in configuration: Both) Ensure that there is a space both before and after pointer qualifiers.

# PointerAlignment: Left                 PointerAlignment: Right
# void* const * x = NULL;         vs.     void * const *x = NULL;
SpaceAroundPointerQualifiers: Default

# If false, spaces will be removed before assignment operators.

# true:                                  false:
# int a = 5;                     vs.     int a= 5;
# a += 42;                               a+= 42;
SpaceBeforeAssignmentOperators: true

# If false, spaces will be removed before case colon.

# true:                                   false
# switch (x) {                    vs.     switch (x) {
#   case 1 : break;                         case 1: break;
# }                                       }
SpaceBeforeCaseColon: false 

# Defines in which cases to put a space before opening parentheses.

# Possible values:

# SBPO_Never (in configuration: Never) Never put a space before opening parentheses.

# void f() {
#   if(true) {
#     f();
#   }
# }
# SBPO_ControlStatements (in configuration: ControlStatements) Put a space before opening parentheses only after control statement keywords (for/if/while...).

# void f() {
#   if (true) {
#     f();
#   }
# }
# SBPO_ControlStatementsExceptControlMacros (in configuration: ControlStatementsExceptControlMacros) Same as SBPO_ControlStatements except this option doesn’t apply to ForEach and If macros. This is useful in projects where ForEach/If macros are treated as function calls instead of control statements. SBPO_ControlStatementsExceptForEachMacros remains an alias for backward compatibility.

# void f() {
#   Q_FOREACH(...) {
#     f();
#   }
# }
# SBPO_NonEmptyParentheses (in configuration: NonEmptyParentheses) Put a space before opening parentheses only if the parentheses are not empty i.e. ‘()’

# void() {
#   if (true) {
#     f();
#     g (x, y, z);
#   }
# }
# SBPO_Always (in configuration: Always) Always put a space before opening parentheses, except when it’s prohibited by the syntax rules (in function-like macro definitions) or when determined by other style rules (after unary operators, opening parentheses, etc.)

# void f () {
#   if (true) {
#     f ();
#   }
# }
# SBPO_Custom (in configuration: Custom) Configure each individual space before parentheses in SpaceBeforeParensOptions.
SpaceBeforeParens: Custom

# Control of individual space before parentheses.

# If SpaceBeforeParens is set to Custom, use this to specify how each individual space before parentheses case should be handled. Otherwise, this is ignored.

# # Example of usage:
# SpaceBeforeParens: Custom
# SpaceBeforeParensOptions:
#   AfterControlStatements: true
#   AfterFunctionDefinitionName: true
# Nested configuration flags:

# Precise control over the spacing before parentheses.

# # Should be declared this way:
# SpaceBeforeParens: Custom
# SpaceBeforeParensOptions:
#   AfterControlStatements: true
#   AfterFunctionDefinitionName: true
# bool AfterControlStatements If true, put space betwee control statement keywords (for/if/while…) and opening parentheses.

# true:                                  false:
# if (...) {}                     vs.    if(...) {}
# bool AfterForeachMacros If true, put space between foreach macros and opening parentheses.

# true:                                  false:
# FOREACH (...)                   vs.    FOREACH(...)
#   <loop-body>                            <loop-body>
# bool AfterFunctionDeclarationName If true, put a space between function declaration name and opening parentheses.

# true:                                  false:
# void f ();                      vs.    void f();
# bool AfterFunctionDefinitionName If true, put a space between function definition name and opening parentheses.

# true:                                  false:
# void f () {}                    vs.    void f() {}
# bool AfterIfMacros If true, put space between if macros and opening parentheses.

# true:                                  false:
# IF (...)                        vs.    IF(...)
#   <conditional-body>                     <conditional-body>
# bool AfterOverloadedOperator If true, put a space between operator overloading and opening parentheses.

# true:                                  false:
# void operator++ (int a);        vs.    void operator++(int a);
# object.operator++ (10);                object.operator++(10);
# bool AfterRequiresInClause If true, put space between requires keyword in a requires clause and opening parentheses, if there is one.

# true:                                  false:
# template<typename T>            vs.    template<typename T>
# requires (A<T> && B<T>)                requires(A<T> && B<T>)
# ...                                    ...
# bool AfterRequiresInExpression If true, put space between requires keyword in a requires expression and opening parentheses.

# true:                                  false:
# template<typename T>            vs.    template<typename T>
# concept C = requires (T t) {           concept C = requires(T t) {
#               ...                                    ...
#             }                                      }
# bool BeforeNonEmptyParentheses If true, put a space before opening parentheses only if the parentheses are not empty.

# true:                                  false:
# void f (int a);                 vs.    void f();
# f (a);                                 f();
SpaceBeforeParensOptions: 
  AfterControlStatements: true
  AfterForeachMacros: true
  AfterFunctionDeclarationName: false
  AfterFunctionDefinitionName: false
  AfterIfMacros: true
  BeforeNonEmptyParentheses: false

# If false, spaces will be removed before range-based for loop colon.

# true:                                  false:
# for (auto v : values) {}       vs.     for(auto v: values) {}
SpaceBeforeRangeBasedForLoopColon: true

# If true, spaces will be before [. Lambdas will not be affected. Only the first [ will get a space added.

# true:                                  false:
# int a [5];                    vs.      int a[5];
# int a [5][5];                 vs.      int a[5][5];
SpaceBeforeSquareBrackets: false

# If true, spaces will be inserted into {}.

# true:                                false:
# void f() { }                   vs.   void f() {}
# while (true) { }                     while (true) {}
SpaceInEmptyBlock: false

# If true, spaces may be inserted into ().

# true:                                false:
# void f( ) {                    vs.   void f() {
#   int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};
#   if (true) {                          if (true) {
#     f( );                                f();
#   }                                    }
# }                                    }
SpaceInEmptyParentheses: false 

# The number of spaces before trailing line comments (// - comments).

# This does not affect trailing block comments (/* - comments) as those commonly have different usage patterns and a number of special cases.

# SpacesBeforeTrailingComments: 3
# void f() {
#   if (true) {   // foo1
#     f();        // bar
#   }             // foo
# }
SpacesBeforeTrailingComments: 3

# If true, spaces may be inserted into C style casts.

# true:                                  false:
# x = ( int32 )y                 vs.     x = (int32)y
SpacesInCStyleCastParentheses: false

# If true, spaces will be inserted around if/for/switch/while conditions.

# true:                                  false:
# if ( a )  { ... }              vs.     if (a) { ... }
# while ( i < 5 )  { ... }               while (i < 5) { ... }
SpacesInConditionalStatement: false 

# How many spaces are allowed at the start of a line comment. To disable the maximum set it to -1, apart from that the maximum takes precedence over the minimum.

# Minimum = 1
# Maximum = -1
# // One space is forced

# //  but more spaces are possible

# Minimum = 0
# Maximum = 0
# //Forces to start every comment directly after the slashes
# Note that in line comment sections the relative indent of the subsequent lines is kept, that means the following:

# before:                                   after:
# Minimum: 1
# //if (b) {                                // if (b) {
# //  return true;                          //   return true;
# //}                                       // }

# Maximum: 0
# /// List:                                 ///List:
# ///  - Foo                                /// - Foo
# ///    - Bar                              ///   - Bar
# Nested configuration flags:

# Control of spaces within a single line comment

# unsigned Minimum The minimum number of spaces at the start of the comment.
# unsigned Maximum The maximum number of spaces at the start of the comment.
SpacesInLineCommentPrefix: 
  Minimum: 1
  Maximum: 1

# If true, spaces will be inserted after ( and before ).

# true:                                  false:
# t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;
SpacesInParentheses: false

# If true, spaces will be inserted after [ and before ]. Lambdas without arguments or unspecified size array declarations will not be affected.

# true:                                  false:
# int a[ 5 ];                    vs.     int a[5];
# std::unique_ptr<int[]> foo() {} // Won't be affected
SpacesInSquareBrackets: false

# Macros which are ignored in front of a statement, as if they were an attribute. So that they are not parsed as identifier, for example for Qts emit.

# AlignConsecutiveDeclarations: true
# StatementAttributeLikeMacros: []
# unsigned char data = 'x';
# emit          signal(data); // This is parsed as variable declaration.

# AlignConsecutiveDeclarations: true
# StatementAttributeLikeMacros: [emit]
# unsigned char data = 'x';
# emit signal(data); // Now it's fine again.
# StatementAttributeLikeMacros: 

# A vector of macros that should be interpreted as complete statements.

# Typical macros are expressions, and require a semi-colon to be added; sometimes this is not the case, and this allows to make clang-format aware of such cases.

# For example: Q_UNUSED
# StatementMacros:

## TabWidth
# The number of columns used for tab stops.
# TabWidth: 0

## TypenameMacros
# A vector of macros that should be interpreted as type declarations instead of as function calls.

# These are expected to be macros of the form:

# STACK_OF(...)
# In the .clang-format configuration file, this can be configured like:

# TypenameMacros: ['STACK_OF', 'LIST']
# For example: OpenSSL STACK_OF, BSD LIST_ENTRY.

# UseCRLF (Boolean) clang-format 10
# Use \r\n instead of \n for line breaks. Also used as fallback if DeriveLineEnding is true.
UseCRLF: false 

# UseTab (UseTabStyle) clang-format 3.7
# The way to use tab characters in the resulting file.

# Possible values:

# UT_Never (in configuration: Never) Never use tab.
# UT_ForIndentation (in configuration: ForIndentation) Use tabs only for indentation.
# UT_ForContinuationAndIndentation (in configuration: ForContinuationAndIndentation) Fill all leading whitespace with tabs, and use spaces for alignment that appears within a line (e.g. consecutive assignments and declarations).
# UT_AlignWithSpaces (in configuration: AlignWithSpaces) Use tabs for line continuation and indentation, and spaces for alignment.
# UT_Always (in configuration: Always) Use tabs whenever we need to fill whitespace that spans at least from one tab stop to the next one.
UseTab: Never

# WhitespaceSensitiveMacros (List of Strings) clang-format 11
# A vector of macros which are whitespace-sensitive and should not be touched.

# These are expected to be macros of the form:

# STRINGIZE(...)
# In the .clang-format configuration file, this can be configured like:

# WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']
# For example: BOOST_PP_STRINGIZE