################################################################################
#                                                                              #
#                               GzIS Clang Tidy v0.2                           #
#                                                                              #
####################################################### author: HalisTahaÅžahin #

Checks: >
  -*,
  bugprone-*,
  cert-*,
  clang-analyzer-*,
  darwin-*,
  fuchsia-*,
  google-*,
  linuxkernel-*,
  llvm-*,
  misc-*,
  modernize-*,
  performance-*,
  portability-*,
  readability-*,

# Turn all the warnings from the checks above into errors.
# WarningsAsErrors: '*'

CheckOptions:
  - { key: readability-identifier-naming.ConstantCase, value: lower_case }
  - { key: readability-identifier-naming.ConstantPrefix, value: "" }
  - { key: readability-identifier-naming.ConstantIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.ConstantSuffix, value: "" }
  - {
      key: readability-identifier-naming.ConstantParameterCase,
      value: lower_case,
    }
  - { key: readability-identifier-naming.ConstantParameterPrefix, value: "" }
  - {
      key: readability-identifier-naming.ConstantParameterIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.ConstantParameterSuffix, value: "" }
  - {
      key: readability-identifier-naming.ConstantPointerParameterCase,
      value: lower_case,
    }
  - {
      key: readability-identifier-naming.ConstantPointerParameterPrefix,
      value: "",
    }
  - {
      key: readability-identifier-naming.ConstantPointerParameterIgnoredRegexp,
      value: "",
    }
  - {
      key: readability-identifier-naming.ConstantPointerParameterSuffix,
      value: "",
    }
  - { key: readability-identifier-naming.EnumCase, value: lower_case }
  - { key: readability-identifier-naming.EnumPrefix, value: "" }
  - { key: readability-identifier-naming.EnumSuffix, value: "" }
  - { key: readability-identifier-naming.EnumConstantCase, value: UPPER_CASE }
  - { key: readability-identifier-naming.EnumConstantPrefix, value: "" }
  - { key: readability-identifier-naming.EnumConstantIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.EnumConstantSuffix, value: "" }
  - { key: readability-identifier-naming.FunctionCase, value: lower_case }
  - { key: readability-identifier-naming.FunctionPrefix, value: "" }
  - { key: readability-identifier-naming.FunctionIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.FunctionSuffix, value: "" }
  - { key: readability-identifier-naming.GetConfigPerFile, value: true }
  - { key: readability-identifier-naming.GlobalConstantCase, value: lower_case }
  - { key: readability-identifier-naming.GlobalConstantPrefix, value: "" }
  - {
      key: readability-identifier-naming.GlobalConstantIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.GlobalConstantSuffix, value: "" }
  - { key: readability-identifier-naming.GlobalPointerCase, value: lower_case }
  - { key: readability-identifier-naming.GlobalPointerPrefix, value: "" }
  - { key: readability-identifier-naming.GlobalPointerIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.GlobalPointerSuffix, value: "" }
  - { key: readability-identifier-naming.GlobalVariableCase, value: lower_case }
  - { key: readability-identifier-naming.GlobalVariablePrefix, value: "" }
  - {
      key: readability-identifier-naming.GlobalVariableIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.GlobalVariableSuffix, value: "" }
  - { key: readability-identifier-naming.LocalConstantCase, value: lower_case }
  - { key: readability-identifier-naming.LocalConstantPrefix, value: "" }
  - { key: readability-identifier-naming.LocalConstantIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.LocalConstantSuffix, value: "" }
  - {
      key: readability-identifier-naming.LocalConstantPointerCase,
      value: lower_case,
    }
  - { key: readability-identifier-naming.LocalConstantPointerPrefix, value: "" }
  - {
      key: readability-identifier-naming.LocalConstantPointerIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.LocalConstantPointerSuffix, value: "" }
  - { key: readability-identifier-naming.LocalPointerCase, value: lower_case }
  - { key: readability-identifier-naming.LocalPointerPrefix, value: "" }
  - { key: readability-identifier-naming.LocalPointerIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.LocalPointerSuffix, value: "" }
  - { key: readability-identifier-naming.LocalVariableCase, value: lower_case }
  - { key: readability-identifier-naming.LocalVariablePrefix, value: "" }
  - { key: readability-identifier-naming.LocalVariableIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.LocalVariableSuffix, value: "" }
  - {
      key: readability-identifier-naming.MacroDefinitionCase,
      value: UPPER_CASE,
    }
  - { key: readability-identifier-naming.MacroDefinitionPrefix, value: "" }
  - {
      key: readability-identifier-naming.MacroDefinitionIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.MacroDefinitionSuffix, value: "" }
  - { key: readability-identifier-naming.ParameterCase, value: lower_case }
  - { key: readability-identifier-naming.ParameterPrefix, value: "" }
  - { key: readability-identifier-naming.ParameterIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.ParameterSuffix, value: "" }
  - {
      key: readability-identifier-naming.PointerParameterCase,
      value: lower_case,
    }
  - { key: readability-identifier-naming.PointerParameterPrefix, value: "" }
  - {
      key: readability-identifier-naming.PointerParameterIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.PointerParameterSuffix, value: "" }
  - {
      key: readability-identifier-naming.ScopedEnumConstantCase,
      value: lower_case,
    }
  - { key: readability-identifier-naming.ScopedEnumConstantPrefix, value: "" }
  - {
      key: readability-identifier-naming.ScopedEnumConstantIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.ScopedEnumConstantSuffix, value: "" }
  - { key: readability-identifier-naming.StaticConstantCase, value: lower_case }
  - { key: readability-identifier-naming.StaticConstantPrefix, value: "" }
  - {
      key: readability-identifier-naming.StaticConstantIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.StaticConstantSuffix, value: "" }
  - { key: readability-identifier-naming.StaticVariableCase, value: lower_case }
  - { key: readability-identifier-naming.StaticVariablePrefix, value: "" }
  - {
      key: readability-identifier-naming.StaticVariableIgnoredRegexp,
      value: "",
    }
  - { key: readability-identifier-naming.StaticVariableSuffix, value: "" }
  - { key: readability-identifier-naming.StructCase, value: lower_case }
  - { key: readability-identifier-naming.StructPrefix, value: "" }
  - { key: readability-identifier-naming.StructIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.StructSuffix, value: "" }
  - { key: readability-identifier-naming.TypedefCase, value: lower_case }
  - { key: readability-identifier-naming.TypedefPrefix, value: "" }
  - { key: readability-identifier-naming.TypedefIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.TypedefSuffix, value: _gt }
  - { key: readability-identifier-naming.UnionCase, value: lower_case }
  - { key: readability-identifier-naming.UnionPrefix, value: "" }
  - { key: readability-identifier-naming.UnionIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.UnionSuffix, value: "" }
  - { key: readability-identifier-naming.VariableCase, value: lower_case }
  - { key: readability-identifier-naming.VariablePrefix, value: "" }
  - { key: readability-identifier-naming.VariableIgnoredRegexp, value: "" }
  - { key: readability-identifier-naming.VariableSuffix, value: "" }
# Casing types include:

# lower_case,
# UPPER_CASE,
# camelBack,
# CamelCase,
# camel_Snake_Back,
# Camel_Snake_Case,
# aNy_CasE.

## SETTINGS

#   ConstantCase
# When defined, the check will ensure constant names conform to the selected casing.

# ConstantPrefix
# When defined, the check will ensure constant names will add the prefixed with the given value (regardless of casing).

# ConstantIgnoredRegexp
# Identifier naming checks won't be enforced for constant names matching this regular expression.

# ConstantSuffix
# When defined, the check will ensure constant names will add the suffix with the given value (regardless of casing).

# ConstantHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# ConstantCase of lower_case
# ConstantPrefix of pre_
# ConstantSuffix of _post
# ConstantHungarianPrefix of On
# Identifies and/or transforms constant names as follows:

# Before:

# void function() { unsigned const MyConst_array[] = {1, 2, 3}; }
# After:

# void function() { unsigned const pre_myconst_array_post[] = {1, 2, 3}; }

# ConstantParameterCase
# When defined, the check will ensure constant parameter names conform to the selected casing.

# ConstantParameterPrefix
# When defined, the check will ensure constant parameter names will add the prefixed with the given value (regardless of casing).

# ConstantParameterIgnoredRegexp
# Identifier naming checks won't be enforced for constant parameter names matching this regular expression.

# ConstantParameterSuffix
# When defined, the check will ensure constant parameter names will add the suffix with the given value (regardless of casing).

# ConstantParameterHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# ConstantParameterCase of lower_case
# ConstantParameterPrefix of pre_
# ConstantParameterSuffix of _post
# ConstantParameterHungarianPrefix of On
# Identifies and/or transforms constant parameter names as follows:

# Before:

# void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);
# After:

# void GLOBAL_FUNCTION(int PARAMETER_1, int const pre_const_parameter_post);

# ConstantPointerParameterCase
# When defined, the check will ensure constant pointer parameter names conform to the selected casing.

# ConstantPointerParameterPrefix
# When defined, the check will ensure constant pointer parameter names will add the prefixed with the given value (regardless of casing).

# ConstantPointerParameterIgnoredRegexp
# Identifier naming checks won't be enforced for constant pointer parameter names matching this regular expression.

# ConstantPointerParameterSuffix
# When defined, the check will ensure constant pointer parameter names will add the suffix with the given value (regardless of casing).

# ConstantPointerParameterHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# ConstantPointerParameterCase of lower_case
# ConstantPointerParameterPrefix of pre_
# ConstantPointerParameterSuffix of _post
# ConstantPointerParameterHungarianPrefix of On
# Identifies and/or transforms constant pointer parameter names as follows:

# Before:

# void GLOBAL_FUNCTION(int const *CONST_parameter);
# After:

# void GLOBAL_FUNCTION(int const *pre_const_parameter_post);

# EnumCase
# When defined, the check will ensure enumeration names conform to the selected casing.

# EnumPrefix
# When defined, the check will ensure enumeration names will add the prefixed with the given value (regardless of casing).

# EnumIgnoredRegexp
# Identifier naming checks won't be enforced for enumeration names matching this regular expression.

# EnumSuffix
# When defined, the check will ensure enumeration names will add the suffix with the given value (regardless of casing).

# For example using values of:

# EnumCase of lower_case
# EnumPrefix of pre_
# EnumSuffix of _post
# Identifies and/or transforms enumeration names as follows:

# Before:

# enum FOO { One, Two, Three };
# After:

# enum pre_foo_post { One, Two, Three };

# EnumConstantCase
# When defined, the check will ensure enumeration constant names conform to the selected casing.

# EnumConstantPrefix
# When defined, the check will ensure enumeration constant names will add the prefixed with the given value (regardless of casing).

# EnumConstantIgnoredRegexp
# Identifier naming checks won't be enforced for enumeration constant names matching this regular expression.

# EnumConstantSuffix
# When defined, the check will ensure enumeration constant names will add the suffix with the given value (regardless of casing).

# EnumConstantHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# EnumConstantCase of lower_case
# EnumConstantPrefix of pre_
# EnumConstantSuffix of _post
# EnumConstantHungarianPrefix of On
# Identifies and/or transforms enumeration constant names as follows:

# Before:

# enum FOO { One, Two, Three };
# After:

# enum FOO { pre_One_post, pre_Two_post, pre_Three_post };

# FunctionCase
# When defined, the check will ensure function names conform to the selected casing.

# FunctionPrefix
# When defined, the check will ensure function names will add the prefixed with the given value (regardless of casing).

# FunctionIgnoredRegexp
# Identifier naming checks won't be enforced for function names matching this regular expression.

# FunctionSuffix
# When defined, the check will ensure function names will add the suffix with the given value (regardless of casing).

# For example using values of:

# FunctionCase of lower_case
# FunctionPrefix of pre_
# FunctionSuffix of _post
# Identifies and/or transforms function names as follows:

# Before:

# char MY_Function_string();
# After:

# char pre_my_function_string_post();

# GetConfigPerFile
# When true the check will look for the configuration for where an identifier is declared. Useful for when included header files use a different style. Default value is true.

# GlobalConstantCase
# When defined, the check will ensure global constant names conform to the selected casing.

# GlobalConstantPrefix
# When defined, the check will ensure global constant names will add the prefixed with the given value (regardless of casing).

# GlobalConstantIgnoredRegexp
# Identifier naming checks won't be enforced for global constant names matching this regular expression.

# GlobalConstantSuffix
# When defined, the check will ensure global constant names will add the suffix with the given value (regardless of casing).

# GlobalConstantHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# GlobalConstantCase of lower_case
# GlobalConstantPrefix of pre_
# GlobalConstantSuffix of _post
# GlobalConstantHungarianPrefix of On
# Identifies and/or transforms global constant names as follows:

# Before:

# unsigned const MyConstGlobal_array[] = {1, 2, 3};
# After:

# unsigned const pre_myconstglobal_array_post[] = {1, 2, 3};

# GlobalConstantPointerCase
# When defined, the check will ensure global constant pointer names conform to the selected casing.

# GlobalConstantPointerPrefix
# When defined, the check will ensure global constant pointer names will add the prefixed with the given value (regardless of casing).

# GlobalConstantPointerIgnoredRegexp
# Identifier naming checks won't be enforced for global constant pointer names matching this regular expression.

# GlobalConstantPointerSuffix
# When defined, the check will ensure global constant pointer names will add the suffix with the given value (regardless of casing).

# GlobalConstantPointerHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# GlobalConstantPointerCase of lower_case
# GlobalConstantPointerPrefix of pre_
# GlobalConstantPointerSuffix of _post
# GlobalConstantPointerHungarianPrefix of On
# Identifies and/or transforms global constant pointer names as follows:

# Before:

# int *const MyConstantGlobalPointer = nullptr;
# After:

# int *const pre_myconstantglobalpointer_post = nullptr;

# GlobalFunctionCase
# When defined, the check will ensure global function names conform to the selected casing.

# GlobalFunctionPrefix
# When defined, the check will ensure global function names will add the prefixed with the given value (regardless of casing).

# GlobalFunctionIgnoredRegexp
# Identifier naming checks won't be enforced for global function names matching this regular expression.

# GlobalFunctionSuffix
# When defined, the check will ensure global function names will add the suffix with the given value (regardless of casing).

# For example using values of:

# GlobalFunctionCase of lower_case
# GlobalFunctionPrefix of pre_
# GlobalFunctionSuffix of _post
# Identifies and/or transforms global function names as follows:

# Before:

# void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);
# After:

# void pre_global_function_post(int PARAMETER_1, int const CONST_parameter);

# GlobalPointerCase
# When defined, the check will ensure global pointer names conform to the selected casing.

# GlobalPointerPrefix
# When defined, the check will ensure global pointer names will add the prefixed with the given value (regardless of casing).

# GlobalPointerIgnoredRegexp
# Identifier naming checks won't be enforced for global pointer names matching this regular expression.

# GlobalPointerSuffix
# When defined, the check will ensure global pointer names will add the suffix with the given value (regardless of casing).

# GlobalPointerHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# GlobalPointerCase of lower_case
# GlobalPointerPrefix of pre_
# GlobalPointerSuffix of _post
# GlobalPointerHungarianPrefix of On
# Identifies and/or transforms global pointer names as follows:

# Before:

# int *GLOBAL3;
# After:

# int *pre_global3_post;

# GlobalVariableCase
# When defined, the check will ensure global variable names conform to the selected casing.

# GlobalVariablePrefix
# When defined, the check will ensure global variable names will add the prefixed with the given value (regardless of casing).

# GlobalVariableIgnoredRegexp
# Identifier naming checks won't be enforced for global variable names matching this regular expression.

# GlobalVariableSuffix
# When defined, the check will ensure global variable names will add the suffix with the given value (regardless of casing).

# GlobalVariableHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# GlobalVariableCase of lower_case
# GlobalVariablePrefix of pre_
# GlobalVariableSuffix of _post
# GlobalVariableHungarianPrefix of On
# Identifies and/or transforms global variable names as follows:

# Before:

# int GLOBAL3;
# After:

# int pre_global3_post;

# LocalConstantCase
# When defined, the check will ensure local constant names conform to the selected casing.

# LocalConstantPrefix
# When defined, the check will ensure local constant names will add the prefixed with the given value (regardless of casing).

# LocalConstantIgnoredRegexp
# Identifier naming checks won't be enforced for local constant names matching this regular expression.

# LocalConstantSuffix
# When defined, the check will ensure local constant names will add the suffix with the given value (regardless of casing).

# LocalConstantHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# LocalConstantCase of lower_case
# LocalConstantPrefix of pre_
# LocalConstantSuffix of _post
# LocalConstantHungarianPrefix of On
# Identifies and/or transforms local constant names as follows:

# Before:

# void foo() { int const local_Constant = 3; }
# After:

# void foo() { int const pre_local_constant_post = 3; }

# LocalConstantPointerCase
# When defined, the check will ensure local constant pointer names conform to the selected casing.

# LocalConstantPointerPrefix
# When defined, the check will ensure local constant pointer names will add the prefixed with the given value (regardless of casing).

# LocalConstantPointerIgnoredRegexp
# Identifier naming checks won't be enforced for local constant pointer names matching this regular expression.

# LocalConstantPointerSuffix
# When defined, the check will ensure local constant pointer names will add the suffix with the given value (regardless of casing).

# LocalConstantPointerHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# LocalConstantPointerCase of lower_case
# LocalConstantPointerPrefix of pre_
# LocalConstantPointerSuffix of _post
# LocalConstantPointerHungarianPrefix of On
# Identifies and/or transforms local constant pointer names as follows:

# Before:

# void foo() { int const *local_Constant = 3; }
# After:

# void foo() { int const *pre_local_constant_post = 3; }

# LocalPointerCase
# When defined, the check will ensure local pointer names conform to the selected casing.

# LocalPointerPrefix
# When defined, the check will ensure local pointer names will add the prefixed with the given value (regardless of casing).

# LocalPointerIgnoredRegexp
# Identifier naming checks won't be enforced for local pointer names matching this regular expression.

# LocalPointerSuffix
# When defined, the check will ensure local pointer names will add the suffix with the given value (regardless of casing).

# LocalPointerHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# LocalPointerCase of lower_case
# LocalPointerPrefix of pre_
# LocalPointerSuffix of _post
# LocalPointerHungarianPrefix of On
# Identifies and/or transforms local pointer names as follows:

# Before:

# void foo() { int *local_Constant; }
# After:

# void foo() { int *pre_local_constant_post; }

# LocalVariableCase
# When defined, the check will ensure local variable names conform to the selected casing.

# LocalVariablePrefix
# When defined, the check will ensure local variable names will add the prefixed with the given value (regardless of casing).

# LocalVariableIgnoredRegexp
# Identifier naming checks won't be enforced for local variable names matching this regular expression.

# For example using values of:

# LocalVariableCase of CamelCase
# LocalVariableIgnoredRegexp of \w{1,2}
# Will exclude variables with a length less than or equal to 2 from the camel case check applied to other variables.

# LocalVariableSuffix
# When defined, the check will ensure local variable names will add the suffix with the given value (regardless of casing).

# LocalVariableHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# LocalVariableCase of lower_case
# LocalVariablePrefix of pre_
# LocalVariableSuffix of _post
# LocalVariableHungarianPrefix of On
# Identifies and/or transforms local variable names as follows:

# Before:

# void foo() { int local_Constant; }
# After:

# void foo() { int pre_local_constant_post; }

# MacroDefinitionCase
# When defined, the check will ensure macro definitions conform to the selected casing.

# MacroDefinitionPrefix
# When defined, the check will ensure macro definitions will add the prefixed with the given value (regardless of casing).

# MacroDefinitionIgnoredRegexp
# Identifier naming checks won't be enforced for macro definitions matching this regular expression.

# MacroDefinitionSuffix
# When defined, the check will ensure macro definitions will add the suffix with the given value (regardless of casing).

# For example using values of:

# MacroDefinitionCase of lower_case
# MacroDefinitionPrefix of pre_
# MacroDefinitionSuffix of _post
# Identifies and/or transforms macro definitions as follows:

# Before:

# #define MY_MacroDefinition
# After:

# #define pre_my_macro_definition_post

# Note: This will not warn on builtin macros or macros defined on the command line using the -D flag.

# ParameterCase
# When defined, the check will ensure parameter names conform to the selected casing.

# ParameterPrefix
# When defined, the check will ensure parameter names will add the prefixed with the given value (regardless of casing).

# ParameterIgnoredRegexp
# Identifier naming checks won't be enforced for parameter names matching this regular expression.

# ParameterSuffix
# When defined, the check will ensure parameter names will add the suffix with the given value (regardless of casing).

# ParameterHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# ParameterCase of lower_case
# ParameterPrefix of pre_
# ParameterSuffix of _post
# ParameterHungarianPrefix of On
# Identifies and/or transforms parameter names as follows:

# Before:

# void GLOBAL_FUNCTION(int PARAMETER_1, int const CONST_parameter);
# After:

# void GLOBAL_FUNCTION(int pre_parameter_post, int const CONST_parameter);

# PointerParameterCase
# When defined, the check will ensure pointer parameter names conform to the selected casing.

# PointerParameterPrefix
# When defined, the check will ensure pointer parameter names will add the prefixed with the given value (regardless of casing).

# PointerParameterIgnoredRegexp
# Identifier naming checks won't be enforced for pointer parameter names matching this regular expression.

# PointerParameterSuffix
# When defined, the check will ensure pointer parameter names will add the suffix with the given value (regardless of casing).

# PointerParameterHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# PointerParameterCase of lower_case
# PointerParameterPrefix of pre_
# PointerParameterSuffix of _post
# PointerParameterHungarianPrefix of On
# Identifies and/or transforms pointer parameter names as follows:

# Before:

# void FUNCTION(int *PARAMETER);
# After:

# void FUNCTION(int *pre_parameter_post);

# ScopedEnumConstantCase
# When defined, the check will ensure scoped enum constant names conform to the selected casing.

# ScopedEnumConstantPrefix
# When defined, the check will ensure scoped enum constant names will add the prefixed with the given value (regardless of casing).

# ScopedEnumConstantIgnoredRegexp
# Identifier naming checks won't be enforced for scoped enum constant names matching this regular expression.

# ScopedEnumConstantSuffix
# When defined, the check will ensure scoped enum constant names will add the suffix with the given value (regardless of casing).

# ScopedEnumConstantHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# ScopedEnumConstantCase of lower_case
# ScopedEnumConstantPrefix of pre_
# ScopedEnumConstantSuffix of _post
# ScopedEnumConstantHungarianPrefix of On
# Identifies and/or transforms enumeration constant names as follows:

# Before:

# enum class FOO { One, Two, Three };
# After:

# enum class FOO { pre_One_post, pre_Two_post, pre_Three_post };

# StaticConstantCase
# When defined, the check will ensure static constant names conform to the selected casing.

# StaticConstantPrefix
# When defined, the check will ensure static constant names will add the prefixed with the given value (regardless of casing).

# StaticConstantIgnoredRegexp
# Identifier naming checks won't be enforced for static constant names matching this regular expression.

# StaticConstantSuffix
# When defined, the check will ensure static constant names will add the suffix with the given value (regardless of casing).

# StaticConstantHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# StaticConstantCase of lower_case
# StaticConstantPrefix of pre_
# StaticConstantSuffix of _post
# StaticConstantHungarianPrefix of On
# Identifies and/or transforms static constant names as follows:

# Before:

# static unsigned const MyConstStatic_array[] = {1, 2, 3};
# After:

# static unsigned const pre_myconststatic_array_post[] = {1, 2, 3};

# StaticVariableCase
# When defined, the check will ensure static variable names conform to the selected casing.

# StaticVariablePrefix
# When defined, the check will ensure static variable names will add the prefixed with the given value (regardless of casing).

# StaticVariableIgnoredRegexp
# Identifier naming checks won't be enforced for static variable names matching this regular expression.

# StaticVariableSuffix
# When defined, the check will ensure static variable names will add the suffix with the given value (regardless of casing).

# StaticVariableHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# StaticVariableCase of lower_case
# StaticVariablePrefix of pre_
# StaticVariableSuffix of _post
# StaticVariableHungarianPrefix of On
# Identifies and/or transforms static variable names as follows:

# Before:

# static unsigned MyStatic_array[] = {1, 2, 3};
# After:

# static unsigned pre_mystatic_array_post[] = {1, 2, 3};

# StructCase
# When defined, the check will ensure struct names conform to the selected casing.

# StructPrefix
# When defined, the check will ensure struct names will add the prefixed with the given value (regardless of casing).

# StructIgnoredRegexp
# Identifier naming checks won't be enforced for struct names matching this regular expression.

# StructSuffix
# When defined, the check will ensure struct names will add the suffix with the given value (regardless of casing).

# For example using values of:

# StructCase of lower_case
# StructPrefix of pre_
# StructSuffix of _post
# Identifies and/or transforms struct names as follows:

# Before:

# struct FOO {
#   FOO();
#   ~FOO();
# };
# After:

# struct pre_foo_post {
#   pre_foo_post();
#   ~pre_foo_post();
# };

# TypedefCase
# When defined, the check will ensure typedef names conform to the selected casing.

# TypedefPrefix
# When defined, the check will ensure typedef names will add the prefixed with the given value (regardless of casing).

# TypedefIgnoredRegexp
# Identifier naming checks won't be enforced for typedef names matching this regular expression.

# TypedefSuffix
# When defined, the check will ensure typedef names will add the suffix with the given value (regardless of casing).

# For example using values of:

# TypedefCase of lower_case
# TypedefPrefix of pre_
# TypedefSuffix of _post
# Identifies and/or transforms typedef names as follows:

# Before:

# typedef int MYINT;
# After:

# typedef int pre_myint_post;

# UnionCase
# When defined, the check will ensure union names conform to the selected casing.

# UnionPrefix
# When defined, the check will ensure union names will add the prefixed with the given value (regardless of casing).

# UnionIgnoredRegexp
# Identifier naming checks won't be enforced for union names matching this regular expression.

# UnionSuffix
# When defined, the check will ensure union names will add the suffix with the given value (regardless of casing).

# For example using values of:

# UnionCase of lower_case
# UnionPrefix of pre_
# UnionSuffix of _post
# Identifies and/or transforms union names as follows:

# Before:

# union FOO {
#   int a;
#   char b;
# };
# After:

# union pre_foo_post {
#   int a;
#   char b;
# };

# VariableCase
# When defined, the check will ensure variable names conform to the selected casing.

# VariablePrefix
# When defined, the check will ensure variable names will add the prefixed with the given value (regardless of casing).

# VariableIgnoredRegexp
# Identifier naming checks won't be enforced for variable names matching this regular expression.

# VariableSuffix
# When defined, the check will ensure variable names will add the suffix with the given value (regardless of casing).

# VariableHungarianPrefix
# When enabled, the check ensures that the declared identifier will have a Hungarian notation prefix based on the declared type.

# For example using values of:

# VariableCase of lower_case
# VariablePrefix of pre_
# VariableSuffix of _post
# VariableHungarianPrefix of On
# Identifies and/or transforms variable names as follows:

# Before:

# unsigned MyVariable;
# After:

# unsigned pre_myvariable_post;

